{
  "hash": "bbf20641e66874d07fe3556206a87170",
  "result": {
    "markdown": "---\ntitle: \"Understanding base documentation functions\"\nauthor: \"James Otto\"\ndate: \"1/24/2022\"\nimage: Understanding-base-documentation-functions.png\noutput: \n  html:\n    highlight: tango\n---\n\n\n## Introduction\n\n<!-- I am working on a <a href=\"https://github.com/jamesotto852/tldr\">project</a> dealing with documentation in R -->\n\nI am working on a project dealing with documentation in R and recently did a deep-dive into how `?` and `help()` work. This post summarizes what I've learned about these functions, first briefly discussing how they \"work\" in a general sense, then going through their implementations line-by-line to understand the functions at a low-level.\n\n## How they \"work\"\n\nThe `?` operator is just a convenience function, allowing users to retrieve documentation on objects specified in a variety of ways. Below I've included a few examples which all do the same thing, showcasing how flexible `?` is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?anova\n?anova()\n?anova(lm(speed ~ dist, cars))\n?anova(stop())\n?\"anova\"\n?stats::anova\n```\n:::\n\n\nIt achieves this flexibility by using functions like `substitute()` and `eval()` to parse its input, eventually leading to a call to `help()`, `help.search()`, `.helpForCall()`, or `.tryHelp()`.\n\nThese are all very similar, and it is sufficient to look into the `help()` function to understand what is going on. The main way `help()` works is by using the functions `loadedNamespaces()`, `find.package()`, and `utils:::index.search()` to find the relevant package files and documentation. Again `help()` has been implemented to be very flexible, accepting arguments in a variety of forms.\n\n## How they work: the nitty-gritty\n\n### `?`\n\nFirst, let's look at the definition of `?`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`?`\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines}\nfunction (e1, e2) \n{\n    if (missing(e2)) {\n        type <- NULL\n        topicExpr <- substitute(e1)\n    }\n    else {\n        type <- substitute(e1)\n        topicExpr <- substitute(e2)\n    }\n    search <- (is.call(topicExpr) && topicExpr[[1L]] == \"?\")\n    if (search) {\n        topicExpr <- topicExpr[[2L]]\n        if (is.call(te <- topicExpr) && te[[1L]] == \"?\" && is.call(te <- topicExpr[[2L]]) && \n            te[[1L]] == \"?\") {\n            cat(\"Contacting Delphi...\")\n            flush.console()\n            Sys.sleep(2 + stats::rpois(1, 2))\n            cat(\"the oracle is unavailable.\\nWe apologize for any inconvenience.\\n\")\n            return(invisible())\n        }\n    }\n    if (is.call(topicExpr) && (topicExpr[[1L]] == \"::\" || topicExpr[[1L]] == \n        \":::\")) {\n        package <- as.character(topicExpr[[2L]])\n        topicExpr <- topicExpr[[3L]]\n    }\n    else package <- NULL\n    if (search) {\n        if (is.null(type)) \n            return(eval(substitute(help.search(TOPIC, package = PACKAGE), \n                list(TOPIC = as.character(topicExpr), PACKAGE = package))))\n        else return(eval(substitute(help.search(TOPIC, fields = FIELD, \n            package = PACKAGE), list(TOPIC = as.character(topicExpr), \n            FIELD = as.character(type), PACKAGE = package))))\n    }\n    else {\n        if (is.null(type)) {\n            if (is.call(topicExpr)) \n                return(.helpForCall(topicExpr, parent.frame()))\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else e1\n            return(eval(substitute(help(TOPIC, package = PACKAGE), \n                list(TOPIC = topic, PACKAGE = package))))\n        }\n        else {\n            type <- if (is.name(type)) \n                as.character(type)\n            else e1\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else {\n                if (is.call(topicExpr) && identical(type, \"method\")) \n                  return(.helpForCall(topicExpr, parent.frame(), \n                    FALSE))\n                e2\n            }\n            if (type == \"package\") \n                package <- topic\n            h <- .tryHelp(topicName(type, topic), package = package)\n            if (is.null(h)) {\n                if (is.language(topicExpr)) \n                  topicExpr <- deparse(topicExpr)\n                stop(gettextf(\"no documentation of type %s and topic %s (or error in processing help)\", \n                  sQuote(type), sQuote(topicExpr)), domain = NA)\n            }\n            h\n        }\n    }\n}\n<bytecode: 0x55cf73a1f258>\n<environment: namespace:utils>\n```\n:::\n:::\n\n\nThat's a big wall of code. We're going to go through the definition in chunks to better understand what is going on.\n\n------------------------------------------------------------------------\n\nImmediately, there's something I didn't know before: `?` is a function of two arguments! After reading through the documentation, it looks like the optional second argument, `e2`, allows for documentation of S4 methods. <!-- For use-cases relevant to `tldr()` (at least at present), `e2` would never be specified, and the `if (missing(e2))` condition will always evaluate to `TRUE`. --> For most use-cases, `e2` will never be specified and the `if (missing(e2))` condition will always evaluate to `TRUE`. This means `type` will almost always be `NULL`, and `topicExpr` will always be `e1` (the only argument supplied to `?`).\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"1\"}\nfunction (e1, e2)\n{\n    if (missing(e2)) {\n        type <- NULL\n        topicExpr <- substitute(e1)\n    }\n    else {\n        type <- substitute(e1)\n        topicExpr <- substitute(e2)\n    }\n```\n:::\n:::\n\n\nAbove, note the use of `substitute()`. <a href=\"https://adv-r.hadley.nz/quasiquotation.html?q=substitute#substitution\">Advanced R</a> covers how `substitute()` is used for quoting. This is exactly what's going on here---it is being used to capture the unevaluated argument, `e1`, assigning it to the variable `topicExpr` (technically, `substitute()` returns a \"parse tree\"). The rest of the code is going to deal with picking apart `topicExpr` to determine what documentation to serve up.\n\n------------------------------------------------------------------------\n\nNext up, we're defining a Boolean variable: `search`:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"11\"}\n    search <- (is.call(topicExpr) && topicExpr[[1L]] == \"?\")\n```\n:::\n:::\n\n\nSee that `search` is `TRUE` whenever 1.) `topicExpr` is an unevaluated function call and 2.) the first element of the parse tree returned by `substitute()` is the function `?`. Why does this matter? It turns out, `??` is **not** a function--- it is the composition of two `?` operators! For example: when you run `??tibble` you are actually executing \\``` ?`(?tibble) ``.\n\nSo, `search` is `TRUE` when the double question mark has been used. This makes sense, as `??` is used for a more general search of the documentation (using the `help.search()` function, as we'll see later).\n\n------------------------------------------------------------------------\n\nNext up is an Easter Egg. Yup, an Easter Egg. But first, if `search` is `TRUE`, we remove the additional `?` function (the first element of `topicExpr`) on line 13:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"12\"}\n    if (search) {\n        topicExpr <- topicExpr[[2L]]\n        if (is.call(te <- topicExpr) && te[[1L]] == \"?\" && is.call(te <- topicExpr[[2L]]) && \n            te[[1L]] == \"?\") {\n            cat(\"Contacting Delphi...\")\n            flush.console()\n            Sys.sleep(2 + stats::rpois(1, 2))\n            cat(\"the oracle is unavailable.\\nWe apologize for any inconvenience.\\n\")\n            return(invisible())\n        }\n    }\n```\n:::\n:::\n\n\nNow, the Easter Egg. The conditional on lines 14-15 evaluates to `TRUE` if there were four nested `?` functions. In this case, a message about the Oracle of Delphi is printed at the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n????sum\n## Contacting Delphi...the oracle is unavailable.\n## We apologize for any inconvenience.\n```\n:::\n\n\n------------------------------------------------------------------------\n\nMoving on, we now deal with the double and triple colon operators (`::` and `:::`):\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"23\"}\n    if (is.call(topicExpr) && (topicExpr[[1L]] == \"::\" || topicExpr[[1L]] == \n        \":::\")) {\n        package <- as.character(topicExpr[[2L]])\n        topicExpr <- topicExpr[[3L]]\n    }\n    else package <- NULL\n```\n:::\n:::\n\n\nIn the presence of these operators, we assign the relavent package to the `package` variable and the function to the `topicExpr` variable. Below, we have included an example of how this works:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntopicExpr <- substitute(ggplot2::geom_point)\n\ntopicExpr[[1]]\n## `::`\ntopicExpr[[2]]\n## ggplot2\ntopicExpr[[3]]\n## geom_point\n```\n:::\n\n\nIf there is no colon operator designating the desired package, `package` is set to `NULL` on line 28.\n\n------------------------------------------------------------------------\n\nFinally, it's time to actually access the documentation. First, the case of `search` being `TRUE` (`??`) is taken care of:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"29\"}\n    if (search) {\n        if (is.null(type)) \n            return(eval(substitute(help.search(TOPIC, package = PACKAGE), \n                list(TOPIC = as.character(topicExpr), PACKAGE = package))))\n        else return(eval(substitute(help.search(TOPIC, fields = FIELD, \n            package = PACKAGE), list(TOPIC = as.character(topicExpr), \n            FIELD = as.character(type), PACKAGE = package))))\n    }\n```\n:::\n:::\n\n\nWe see that the function searching through the documentation is `help.search()` -- the variables we have specified thusfar are provided as arguments and we're done.\n\n------------------------------------------------------------------------\n\nNow we take care of the case where `search` is `FALSE` and `type` is `NULL`. Remember, `type` is `NULL` whenever the argument `e2` is not supplied--- <!-- this is the only use case we care about for `tldr()`. --> the most common use-case.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"37\"}\n    else {\n        if (is.null(type)) {\n            if (is.call(topicExpr)) \n                return(.helpForCall(topicExpr, parent.frame()))\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else e1\n            return(eval(substitute(help(TOPIC, package = PACKAGE), \n                list(TOPIC = topic, PACKAGE = package))))\n        }\n```\n:::\n:::\n\n\nA few interesting things to note. First, we deal with the scenario where `topicExpr` is a call, in which case the function being used to access documentation is the unexported `utils:::.helpforCall()`. I haven't dug through its body, but it looks like this is to allow users to execute code like `?sum()` (instead of the more typical `?sum`). But, I've noticed that it doesn't work for everything---for an example run `?c()` .\n\n<!-- Starting on line 41, we have the code which is most directly relevant to `tldr()`. -->\n\nStarting on line 41, we have the main way `?` leads to documentation. This is how code like `?sum` is evaluated, via a call to `help()` on line 44. Notice that `substitute()` is being used in a slightly different way than before, substituting the values in the \"environment\" defined on line 45 before `eval()` is run. (It is used the same way in the previous code chunk, on lines 31 and 33.)\n\n------------------------------------------------------------------------\n\nThe rest of the code is just dealing with the case where `type` and `topic` was specified by `e1` and `e2` arguments, respectively. It's really just repeating what we've seen already, with the small addition of using `utils:::.tryHelp()` and `utils:::topicName()` functions.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"47\"}\n        else {\n            type <- if (is.name(type)) \n                as.character(type)\n            else e1\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else {\n                if (is.call(topicExpr) && identical(type, \"method\")) \n                  return(.helpForCall(topicExpr, parent.frame(), \n                    FALSE))\n                e2\n            }\n            if (type == \"package\") \n                package <- topic\n            h <- .tryHelp(topicName(type, topic), package = package)\n            if (is.null(h)) {\n                if (is.language(topicExpr)) \n                  topicExpr <- deparse(topicExpr)\n                stop(gettextf(\"no documentation of type %s and topic %s (or error in processing help)\", \n                  sQuote(type), sQuote(topicExpr)), domain = NA)\n            }\n            h\n        }\n    }\n}\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nSo, what have we learned? `?` is a convenience function wrapping around functions like `help()` and `help.search()`. It's main purpose is to parse the different ways a user might refer to an object (e.g. `?ggplot2::geom_point`, `??knn`, `?sum()`, `?sum`).\n\n<!-- To implement `tldr()` in a way similar to `?`, we may want to research more modern methods of quoting (i.e. `expr()`). -->\n\n### `help()`\n\nNow that we have a good grasp on what's going on with `?`, let's see how `help()` works. Let's start by echoing the body of the function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines}\nfunction (topic, package = NULL, lib.loc = NULL, verbose = getOption(\"verbose\"), \n    try.all.packages = getOption(\"help.try.all.packages\"), help_type = getOption(\"help_type\")) \n{\n    types <- c(\"text\", \"html\", \"pdf\")\n    help_type <- if (!length(help_type)) \n        \"text\"\n    else match.arg(tolower(help_type), types)\n    if (!missing(package)) \n        if (is.name(y <- substitute(package))) \n            package <- as.character(y)\n    if (missing(topic)) {\n        if (!is.null(package)) {\n            if (interactive() && help_type == \"html\") {\n                port <- tools::startDynamicHelp(NA)\n                if (port <= 0L) \n                  return(library(help = package, lib.loc = lib.loc, \n                    character.only = TRUE))\n                browser <- if (.Platform$GUI == \"AQUA\") {\n                  get(\"aqua.browser\", envir = as.environment(\"tools:RGUI\"))\n                }\n                else getOption(\"browser\")\n                browseURL(paste0(\"http://127.0.0.1:\", port, \"/library/\", \n                  package, \"/html/00Index.html\"), browser)\n                return(invisible())\n            }\n            else return(library(help = package, lib.loc = lib.loc, \n                character.only = TRUE))\n        }\n        if (!is.null(lib.loc)) \n            return(library(lib.loc = lib.loc))\n        topic <- \"help\"\n        package <- \"utils\"\n        lib.loc <- .Library\n    }\n    ischar <- tryCatch(is.character(topic) && length(topic) == \n        1L, error = function(e) FALSE)\n    if (!ischar) {\n        reserved <- c(\"TRUE\", \"FALSE\", \"NULL\", \"Inf\", \"NaN\", \n            \"NA\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\")\n        stopic <- deparse1(substitute(topic))\n        if (!is.name(substitute(topic)) && !stopic %in% reserved) \n            stop(\"'topic' should be a name, length-one character vector or reserved word\")\n        topic <- stopic\n    }\n    paths <- index.search(topic, find.package(if (is.null(package)) \n        loadedNamespaces()\n    else package, lib.loc, verbose = verbose))\n    try.all.packages <- !length(paths) && is.logical(try.all.packages) && \n        !is.na(try.all.packages) && try.all.packages && is.null(package) && \n        is.null(lib.loc)\n    if (try.all.packages) {\n        for (lib in .libPaths()) {\n            packages <- .packages(TRUE, lib)\n            packages <- packages[is.na(match(packages, .packages()))]\n            paths <- c(paths, index.search(topic, file.path(lib, \n                packages)))\n        }\n        paths <- paths[nzchar(paths)]\n    }\n    structure(unique(paths), call = match.call(), topic = topic, \n        tried_all_packages = try.all.packages, type = help_type, \n        class = \"help_files_with_topic\")\n}\n<bytecode: 0x55cf7461ac50>\n<environment: namespace:utils>\n```\n:::\n:::\n\n\nOf course, we'll break this down into more digestible chunks.\n\n------------------------------------------------------------------------\n\nFirst, we are determining what format of documentation to get. There's weird argument matching going on, but the main idea is that help can be served up in three forms: text, html, and pdf. By default, `help()` looks at the global option `\"help_type\"` for this.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"1\"}\nfunction (topic, package = NULL, lib.loc = NULL, verbose = getOption(\"verbose\"),\n  try.all.packages = getOption(\"help.try.all.packages\"), help_type = getOption(\"help_type\")) \n{\n    types <- c(\"text\", \"html\", \"pdf\")\n    help_type <- if (!length(help_type)) \n        \"text\"\n    else match.arg(tolower(help_type), types)\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n<!-- Next, we have some base R shenanigans. -->\n\n<!-- The fact that `<-` retur -->\n\nNext, if the `package` argument is specified, we check that it is a name after it's been quoted. If it is, the quoted argument is coerced into a string for later.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"8\"}\n    if (!missing(package)) \n        if (is.name(y <- substitute(package))) \n            package <- as.character(y)\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nNow, we deal with the case where `topic` is not specified. This is not the typical case, `topic` is the first formal of `help`. For example, when you run `help(geom_point)` you're setting `topic = geom_point`. However, this allows for things like `help(package = ggplot2)`.\n\nThis is what's going on in lines 13-27, `help()` is figuring out how to call `library()` correctly, given the user's environment. It turns out that in addition to loading/attaching packages, when the `help` argument of `library()` is specified it returns information regarding the specified package (in an object of class `\"packageInfo\"`).\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"11\"}\n    if (missing(topic)) {\n        if (!is.null(package)) {\n            if (interactive() && help_type == \"html\") {\n                port <- tools::startDynamicHelp(NA)\n                if (port <= 0L) \n                  return(library(help = package, lib.loc = lib.loc, \n                    character.only = TRUE))\n                browser <- if (.Platform$GUI == \"AQUA\") {\n                  get(\"aqua.browser\", envir = as.environment(\"tools:RGUI\"))\n                }\n                else getOption(\"browser\")\n                browseURL(paste0(\"http://127.0.0.1:\", port, \"/library/\", \n                  package, \"/html/00Index.html\"), browser)\n                return(invisible())\n            }\n            else return(library(help = package, lib.loc = lib.loc, \n                character.only = TRUE))\n        }\n        if (!is.null(lib.loc)) \n            return(library(lib.loc = lib.loc))\n        topic <- \"help\"\n        package <- \"utils\"\n        lib.loc <- .Library\n    }\n```\n:::\n:::\n\n\nNote, we're making use of the `lib.loc` argument. It specifies the location of the `R` library trees on the user's machine. By default, its value is `NULL`---this corresponds to the libraries according to `.libPaths()`.\n\n------------------------------------------------------------------------\n\nNext is some simple cleaning-up of `topic` (which, at this point, we know was specified). Lines 35 and 36 are interesting, note the wrapping of the conditional in a `TryCatch()`.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"35\"}\n    ischar <- tryCatch(is.character(topic) && length(topic) == \n        1L, error = function(e) FALSE)\n    if (!ischar) {\n        reserved <- c(\"TRUE\", \"FALSE\", \"NULL\", \"Inf\", \"NaN\", \n            \"NA\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\")\n        stopic <- deparse1(substitute(topic))\n        if (!is.name(substitute(topic)) && !stopic %in% reserved) \n            stop(\"'topic' should be a name, length-one character vector or reserved word\")\n        topic <- stopic\n    }\n```\n:::\n:::\n\n\nAfter this chunk, we know that `topic` is a string of length 1.\n\n------------------------------------------------------------------------\n\nThe next step is to use the unexported function `utils:::index.search()` to search through relevant package for `topic`. This involves either searching through the entire set of packages in `loadedNamespaces()` or the specified `package`.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"45\"}\n    paths <- index.search(topic, find.package(if (is.null(package)) \n        loadedNamespaces()\n    else package, lib.loc, verbose = verbose))\n```\n:::\n:::\n\n\nBelow, I've included (truncated) output from a few of these functions so that you can see what's going on:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloadedNamespaces()[1:4]\n## [1] \"grDevices\" \"digest\"    \"jsonlite\"  \"magrittr\"\n\nfind.package(loadedNamespaces())[1:4]\n## [1] \"/usr/lib/R/library/grDevices\"                           \n## [2] \"/usr/local/lib/R/site-library/digest\"                   \n## [3] \"/usr/local/lib/R/site-library/jsonlite\"                 \n## [4] \"/home/ubuntu/R/x86_64-pc-linux-gnu-library/4.2/magrittr\"\n\nutils:::index.search(\"anova\", find.package(loadedNamespaces()))\n## [1] \"/usr/lib/R/library/stats/help/anova\"\n```\n:::\n\n\n------------------------------------------------------------------------\n\nNext, we're cleaning up the `try.all.packages` argument. This sequence of logical operators works together to 1.) coerce `try.all.packages` into a logical and 2.) ensure `try.all.packages` is `FALSE` if at all possible (according to the documentation, if `try.all.packages` is `TRUE` there might be performance issues).\n\nBy default (and when it is called from `?`), `try.all.packages` is `FALSE`, so this isn't of much consequence.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"48\"}\n    try.all.packages <- !length(paths) && is.logical(try.all.packages) && \n        !is.na(try.all.packages) && try.all.packages && is.null(package) && \n        is.null(lib.loc)\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nHere is where `try.all.packages` is used. If it is `TRUE`, an `index.search()` is performed for `topic` in every package in the`.libPaths()` directory with results being included in `paths`.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"51\"}\n    if (try.all.packages) {\n        for (lib in .libPaths()) {\n            packages <- .packages(TRUE, lib)\n            packages <- packages[is.na(match(packages, .packages()))]\n            paths <- c(paths, index.search(topic, file.path(lib, \n                packages)))\n        }\n        paths <- paths[nzchar(paths)]\n    }\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nFinally, we have the end of `help()`. This is the code that fetches/loads the relevant documentation. If everything has gone correctly, R will try to find a way to show you the corresponding documentation. (If `try.all.packages` is `TRUE`, a search results page will be shown instead). In Rstudio, for example, the documentation file will appear in the \"Help\" pane.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.r .numberLines startFrom=\"60\"}\n    structure(unique(paths), call = match.call(), topic = topic, \n        tried_all_packages = try.all.packages, type = help_type, \n        class = \"help_files_with_topic\")\n}\n```\n:::\n:::\n\n\nWhy does this `structure()` call result in the documentation being displayed? I have no idea. I imagine it has something to do with the print method of the `\"help_files_with_topic\"` class--- I haven't been able to find great documentation on these details.\n\n------------------------------------------------------------------------\n\nTry it for yourself! Run the following code, it should bring up the documentation for `stats::anova()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_pkgs <- find.package(\n  if (TRUE) loadedNamespaces() else \"stats\", \n  lib.loc = NULL, verbose = getOption(\"verbose\")\n)\n\ntemp_path <- utils:::index.search(\"anova\", temp_pkgs)\n\nstructure(temp_path, call = match.call(), topic = \"anova\", \n    tried_all_packages = FALSE, type = \"html\", \n    class = \"help_files_with_topic\")\n```\n:::\n\n\n------------------------------------------------------------------------\n\nSo, what have we learned? Documentation for functions of **loaded** packages are accessed via a combination of the functions `loadedNamespaces()`, `find.package()`, and `utils:::index.search()`. If we want to access documentation of functions for packages that are not loaded, we need to use the functions `.libPaths()`, `.packages()`, and `utils:::index.search()`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}