[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "James Otto",
    "section": "",
    "text": "I am interested in the studies of computational statistics and density estimation, and enjoy exploring the connections between theoretical mathematics and statistics (especially applications of functional analysis). When not working on research, I’m probably bouldering, practicing aerial silks, or reading.\nHere are a few of my current projects that I’m excited to be working on:\n\nggdensity: Interpretable visualizations of bivariate density estimates\ntldr: Short-form documentation in the R console\nAn Interactive History of Magic the Gathering"
  },
  {
    "objectID": "talks/2022-useR.html",
    "href": "talks/2022-useR.html",
    "title": "ggdensity: Improved Bivariate Density Visualization in R",
    "section": "",
    "text": "Event: useR! 2022\nSlides:"
  },
  {
    "objectID": "talks/2022-JSM.html",
    "href": "talks/2022-JSM.html",
    "title": "ggdensity: Improved Bivariate Density Visualization in R",
    "section": "",
    "text": "Event: JSM 2022\nSlides (source)"
  },
  {
    "objectID": "talks/2022-SDSS.html",
    "href": "talks/2022-SDSS.html",
    "title": "ggdensity: Improved Bivariate Density Visualization in R",
    "section": "",
    "text": "Event: SDSS 2022\nSlides"
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "James Otto",
    "section": "",
    "text": "ggdensity: Improved density visualization in ggplot2\nTDAvis: Visualizing topological data analysis tools\nggspatreg: Plotting spatial regression model predictions\nggrrr: Functional programming with ggplot2 and patchwork\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntldr: Short-form documentation in the R console\ntldrDocs: tldr documentation for base R objects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngoodreadR: Scrape user data from goodreads.com\nfRiend: An octopus greeting in each new R session\n\n\n\n\n\n\n \n\n\n\n\nggdensity: Improved density visualization in ggplot2\nTDAvis: Visualizing topological data analysis tools\nggspatreg: Plotting spatial regression model predictions\nggrrr: Functional programming with ggplot2 and patchwork\n\n\n\n\n\ntldr: Short-form documentation in the R console\ntldrDocs: tldr documentation for base R objects\n\n\n\n\n\ngoodreadR: Scrape user data from goodreads.com\nfRiend: An octopus greeting in each new R session"
  },
  {
    "objectID": "talks.html",
    "href": "talks.html",
    "title": "Talks",
    "section": "",
    "text": "JSM 2022\n\n\n\n\n\n\nAug 7, 2022\n\n\nJames Otto, David Kahle\n\n\n\n\n\n\n  \n\n\n\n\n\nuseR! 2022\n\n\n\n\n\n\nJun 21, 2022\n\n\nJames Otto, David Kahle\n\n\n\n\n\n\n  \n\n\n\n\n\nSDSS 2022\n\n\n\n\n\n\nJun 8, 2022\n\n\nJames Otto, David Kahle\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html",
    "href": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html",
    "title": "Visualizing BoardGameGeek data with ggdensity",
    "section": "",
    "text": "In this blog post, we’re going to be looking at the BoardGameGeek data from week 4 of TidyTuesday 2022. This data set consists of community ratings and other stats for just over 20,000 board games. The first thing we need to do is load in the data and perform some basic cleaning, joining the ratings and details data on the id column:\n\nlibrary(\"tidyverse\")\n\ndata <- tidytuesdayR::tt_load('2022-01-25')\n\ndf <- data$ratings |>\n  left_join(data$details, by = \"id\")"
  },
  {
    "objectID": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html#looking-at-boardgamecategory",
    "href": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html#looking-at-boardgamecategory",
    "title": "Visualizing BoardGameGeek data with ggdensity",
    "section": "Looking at boardgamecategory",
    "text": "Looking at boardgamecategory\nSomething that immediately stands out to me is the variable boardgamecategory. Comparing stats across different types of board games could end up being really interesting! But, there is a problem—this column isn’t “tidy”:\n\nselect(df, name, boardgamecategory) |>\n  slice_head(n = 10)\n\n\n\n\n\n\n\n\n\nname\nboardgamecategory\n\n\n\n\nPandemic\n[‘Medical’]\n\n\nCarcassonne\n[‘City Building’, ‘Medieval’, ‘Territory Building’]\n\n\nCatan\n[‘Economic’, ‘Negotiation’]\n\n\n7 Wonders\n[‘Ancient’, ‘Card Game’, ‘City Building’, ‘Civilization’, ‘Economic’]\n\n\nDominion\n[‘Card Game’, ‘Medieval’]\n\n\nTicket to Ride\n[‘Trains’]\n\n\nCodenames\n[‘Card Game’, ‘Deduction’, ‘Party Game’, ‘Spies/Secret Agents’, ‘Word Game’]\n\n\nTerraforming Mars\n[‘Economic’, ‘Environmental’, ‘Industry / Manufacturing’, ‘Science Fiction’, ‘Space Exploration’, ‘Territory Building’]\n\n\n7 Wonders Duel\n[‘Ancient’, ‘Card Game’, ‘City Building’, ‘Civilization’, ‘Economic’]\n\n\nAgricola\n[‘Animals’, ‘Economic’, ‘Farming’]\n\n\n\n\n\n\nLuckily, this is an easy fix with some string processing. We can use stringr::str_extract_all() to extract the categories from each row into a list, then use tidyr::unnest() to flatten out the resulting list column.\n\ndf <- df |>\n  filter(!is.na(boardgamecategory)) |>\n  mutate(boardgamecategory = str_extract_all(boardgamecategory, \"(?<=')[^,]*(?=')\")) |>\n  unnest(boardgamecategory)\n\nselect(df, name, boardgamecategory) |>\n  slice_head(n = 10)\n\n\n\n\n\nname\nboardgamecategory\n\n\n\n\nPandemic\nMedical\n\n\nCarcassonne\nCity Building\n\n\nCarcassonne\nMedieval\n\n\nCarcassonne\nTerritory Building\n\n\nCatan\nEconomic\n\n\nCatan\nNegotiation\n\n\n7 Wonders\nAncient\n\n\n7 Wonders\nCard Game\n\n\n7 Wonders\nCity Building\n\n\n7 Wonders\nCivilization\n\n\n\n\n\n\nGreat! Now, let’s see what the most popular categories are:\n\ntop_categories <- df |>\n  group_by(boardgamecategory) |>\n  summarize(n = n()) |>\n  arrange(desc(n)) |>\n  slice_head(n = 10)\n\ntop_categories\n\n\n\n\n\nboardgamecategory\nn\n\n\n\n\nCard Game\n6402\n\n\nWargame\n3820\n\n\nFantasy\n2681\n\n\nParty Game\n1968\n\n\nDice\n1847\n\n\nScience Fiction\n1666\n\n\nFighting\n1658\n\n\nAbstract Strategy\n1545\n\n\nEconomic\n1503\n\n\nAnimals\n1354\n\n\n\n\n\n\nSurprisingly, the most popular board game category is “Card Games”! We can create a simple visual showing the prevalence of each of these top 10 categories:\n\n\nCode\ntop_categories |>\n  mutate(boardgamecategory = fct_reorder(boardgamecategory, n, .desc = TRUE)) |>\n  ggplot(aes(x = boardgamecategory, y = n)) +\n  geom_col() +\n  labs(\n    x = \"Category\",\n    y = NULL\n  )"
  },
  {
    "objectID": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html#looking-at-playingtime-minplayers-and-maxplayers",
    "href": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html#looking-at-playingtime-minplayers-and-maxplayers",
    "title": "Visualizing BoardGameGeek data with ggdensity",
    "section": "Looking at playingtime, minplayers, and maxplayers",
    "text": "Looking at playingtime, minplayers, and maxplayers\nLet’s put the work that we’ve done on the categories field on hold for a minute and look at how a game’s average number of players relates to its average play time. Before making any plots, I would suspect that as the number of players increases the average play time increases. That is to say, I would expect positive correlation between the two variables.\n\n\nCode\n# First, we need to do a little more cleaning\n# Filter out some outliers, compute avg_players\ndf <- df |> \n  filter(maxplayers < 20) |>\n  filter(playingtime < 1000) |> \n  mutate(playingtime = playingtime / 60) |>\n  mutate(avg_players = (minplayers + maxplayers)/2) \n  \ndf |>\n  distinct(name, .keep_all = TRUE) |> # Don't care about categories right now\n  ggplot(aes(x = avg_players, y = playingtime)) +\n  geom_jitter(height = .5, width = .5, size = .1, alpha = .5) +\n  scale_x_continuous(breaks = seq(0, 12, by = 2)) +\n  scale_y_continuous(breaks = seq(0, 14, by = 2)) +\n  coord_cartesian(ylim = c(0, 14), expand = FALSE) +\n  labs(\n    x = \"Average no. of players\",\n    y = \"Average play time (Hours)\"\n  )\n\n\n\n\n\nInterestingly, this does not seem to be the case! In fact it seems like it may be the opposite—play time appears to be maximized when there are between 2 and 4 players and drops off as the number of players increases.\nUnfortunately, the above plot has a few issues that stand in the way of us making useful observations. First, I have had to do some severe jittering to eliminate graphical artifacts resulting from the discrete nature of the data. Notice, several of the points seem to correspond to games with fewer than 0 average players! Second, there is pretty severe overplotting. Although I have attempted to avoid this by setting both the size and alpha arguments, the plot is still very crowded—especially around the horizontal axis between the 2 and 4 player ticks.\nFortunately, I know of a tool that can help with both of these issues—ggdensity!\n\n\nCode\nlibrary(\"ggdensity\")\n\ndf |> \n  distinct(name, .keep_all = TRUE) |> # Don't care about categories right now\n  ggplot(aes(x = avg_players, y = playingtime)) +\n  geom_hdr(adjust = c(2, 4)) + # Need to set adjust b/c of discreteness\n  scale_x_continuous(breaks = seq(0, 12, by = 2)) +\n  scale_y_continuous(breaks = seq(0, 14, by = 2)) +\n  coord_cartesian(ylim = c(0, 14), expand = FALSE) +\n  labs(\n    x = \"Average no. of players\",\n    y = \"Average play time (Hours)\"\n  )\n\n\n\n\n\nAbove, we are plotting estimated “Highest Density Regions” (HDRs)— these are the smallest regions containing 50%, 80%, 95%, and 99% of the data (essentially). For more information, check out the ggdensity repo. See that the issues of overplotting and jittering are eliminated as we have abandoned the strategy of plotting individual points. Now that we’ve taken care of these problems, we can see that there is a negative association between the average number of players and average play time. This is unexpected! Let’s look a little deeper, leveraging our previous work on boardgamecategory."
  },
  {
    "objectID": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html#putting-it-all-together",
    "href": "posts/Visualizing-BoardGameGeek-Data-with-ggdensity.html#putting-it-all-together",
    "title": "Visualizing BoardGameGeek data with ggdensity",
    "section": "Putting it all together",
    "text": "Putting it all together\nDoes this negative association hold true across the most popular categories? Or is this yet another example of Simpson’s paradox? There’s only one way to find out—faceting!\n\n\nCode\ndf |> \n  filter(boardgamecategory %in% top_categories$boardgamecategory[1:5]) |>\n  mutate(boardgamecategory = fct_reorder(boardgamecategory, playingtime, mean, .desc = TRUE)) |>\n  ggplot(aes(x = avg_players, y = playingtime, fill = boardgamecategory)) +\n  geom_hdr(adjust = 2) + # Need to set adjust b/c of discreteness\n  facet_wrap(vars(boardgamecategory), ncol = 5) +\n  scale_x_continuous(breaks = seq(0, 12, by = 2)) +\n  scale_y_continuous(breaks = seq(0, 14, by = 2)) +\n  scale_fill_brewer(type = \"qual\", palette = 2, guide = NULL) +\n  coord_cartesian(ylim = c(0, 14), expand = FALSE) +\n  labs(\n    x = \"Average no. of players\",\n    y = \"Average play time (Hours)\"\n  )\n\n\n\n\n\nThis plot offers a new perspective. In each category, it appears to be the case that average play time and number of players are independent. Also, it looks like “Wargame” board games tend to involve fewer players and last signficantly longer than other categories. Combining board games across categories creates the illusion that play time and number of players is negatively correlated—another point for Simpson!"
  },
  {
    "objectID": "posts/Understanding-base-documentation-functions.html",
    "href": "posts/Understanding-base-documentation-functions.html",
    "title": "Understanding base documentation functions",
    "section": "",
    "text": "I am working on a project dealing with documentation in R and recently did a deep-dive into how ? and help() work. This post summarizes what I’ve learned about these functions, first briefly discussing how they “work” in a general sense, then going through their implementations line-by-line to understand the functions at a low-level."
  },
  {
    "objectID": "posts/Understanding-base-documentation-functions.html#how-they-work",
    "href": "posts/Understanding-base-documentation-functions.html#how-they-work",
    "title": "Understanding base documentation functions",
    "section": "How they “work”",
    "text": "How they “work”\nThe ? operator is just a convenience function, allowing users to retrieve documentation on objects specified in a variety of ways. Below I’ve included a few examples which all do the same thing, showcasing how flexible ? is:\n\n?anova\n?anova()\n?anova(lm(speed ~ dist, cars))\n?anova(stop())\n?\"anova\"\n?stats::anova\n\nIt achieves this flexibility by using functions like substitute() and eval() to parse its input, eventually leading to a call to help(), help.search(), .helpForCall(), or .tryHelp().\nThese are all very similar, and it is sufficient to look into the help() function to understand what is going on. The main way help() works is by using the functions loadedNamespaces(), find.package(), and utils:::index.search() to find the relevant package files and documentation. Again help() has been implemented to be very flexible, accepting arguments in a variety of forms."
  },
  {
    "objectID": "posts/Understanding-base-documentation-functions.html#how-they-work-the-nitty-gritty",
    "href": "posts/Understanding-base-documentation-functions.html#how-they-work-the-nitty-gritty",
    "title": "Understanding base documentation functions",
    "section": "How they work: the nitty-gritty",
    "text": "How they work: the nitty-gritty\n\n?\nFirst, let’s look at the definition of ?:\n\n`?`\n\nfunction (e1, e2) \n{\n    if (missing(e2)) {\n        type <- NULL\n        topicExpr <- substitute(e1)\n    }\n    else {\n        type <- substitute(e1)\n        topicExpr <- substitute(e2)\n    }\n    search <- (is.call(topicExpr) && topicExpr[[1L]] == \"?\")\n    if (search) {\n        topicExpr <- topicExpr[[2L]]\n        if (is.call(te <- topicExpr) && te[[1L]] == \"?\" && is.call(te <- topicExpr[[2L]]) && \n            te[[1L]] == \"?\") {\n            cat(\"Contacting Delphi...\")\n            flush.console()\n            Sys.sleep(2 + stats::rpois(1, 2))\n            cat(\"the oracle is unavailable.\\nWe apologize for any inconvenience.\\n\")\n            return(invisible())\n        }\n    }\n    if (is.call(topicExpr) && (topicExpr[[1L]] == \"::\" || topicExpr[[1L]] == \n        \":::\")) {\n        package <- as.character(topicExpr[[2L]])\n        topicExpr <- topicExpr[[3L]]\n    }\n    else package <- NULL\n    if (search) {\n        if (is.null(type)) \n            return(eval(substitute(help.search(TOPIC, package = PACKAGE), \n                list(TOPIC = as.character(topicExpr), PACKAGE = package))))\n        else return(eval(substitute(help.search(TOPIC, fields = FIELD, \n            package = PACKAGE), list(TOPIC = as.character(topicExpr), \n            FIELD = as.character(type), PACKAGE = package))))\n    }\n    else {\n        if (is.null(type)) {\n            if (is.call(topicExpr)) \n                return(.helpForCall(topicExpr, parent.frame()))\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else e1\n            return(eval(substitute(help(TOPIC, package = PACKAGE), \n                list(TOPIC = topic, PACKAGE = package))))\n        }\n        else {\n            type <- if (is.name(type)) \n                as.character(type)\n            else e1\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else {\n                if (is.call(topicExpr) && identical(type, \"method\")) \n                  return(.helpForCall(topicExpr, parent.frame(), \n                    FALSE))\n                e2\n            }\n            if (type == \"package\") \n                package <- topic\n            h <- .tryHelp(topicName(type, topic), package = package)\n            if (is.null(h)) {\n                if (is.language(topicExpr)) \n                  topicExpr <- deparse(topicExpr)\n                stop(gettextf(\"no documentation of type %s and topic %s (or error in processing help)\", \n                  sQuote(type), sQuote(topicExpr)), domain = NA)\n            }\n            h\n        }\n    }\n}\n<bytecode: 0x56147cce9090>\n<environment: namespace:utils>\n\n\nThat’s a big wall of code. We’re going to go through the definition in chunks to better understand what is going on.\n\nImmediately, there’s something I didn’t know before: ? is a function of two arguments! After reading through the documentation, it looks like the optional second argument, e2, allows for documentation of S4 methods.  For most use-cases, e2 will never be specified and the if (missing(e2)) condition will always evaluate to TRUE. This means type will almost always be NULL, and topicExpr will always be e1 (the only argument supplied to ?).\n\n\nfunction (e1, e2)\n{\n    if (missing(e2)) {\n        type <- NULL\n        topicExpr <- substitute(e1)\n    }\n    else {\n        type <- substitute(e1)\n        topicExpr <- substitute(e2)\n    }\n\n\nAbove, note the use of substitute(). Advanced R covers how substitute() is used for quoting. This is exactly what’s going on here—it is being used to capture the unevaluated argument, e1, assigning it to the variable topicExpr (technically, substitute() returns a “parse tree”). The rest of the code is going to deal with picking apart topicExpr to determine what documentation to serve up.\n\nNext up, we’re defining a Boolean variable: search:\n\n\n    search <- (is.call(topicExpr) && topicExpr[[1L]] == \"?\")\n\n\nSee that search is TRUE whenever 1.) topicExpr is an unevaluated function call and 2.) the first element of the parse tree returned by substitute() is the function ?. Why does this matter? It turns out, ?? is not a function— it is the composition of two ? operators! For example: when you run ??tibble you are actually executing `?`(?tibble).\nSo, search is TRUE when the double question mark has been used. This makes sense, as ?? is used for a more general search of the documentation (using the help.search() function, as we’ll see later).\n\nNext up is an Easter Egg. Yup, an Easter Egg. But first, if search is TRUE, we remove the additional ? function (the first element of topicExpr) on line 13:\n\n\n    if (search) {\n        topicExpr <- topicExpr[[2L]]\n        if (is.call(te <- topicExpr) && te[[1L]] == \"?\" && is.call(te <- topicExpr[[2L]]) && \n            te[[1L]] == \"?\") {\n            cat(\"Contacting Delphi...\")\n            flush.console()\n            Sys.sleep(2 + stats::rpois(1, 2))\n            cat(\"the oracle is unavailable.\\nWe apologize for any inconvenience.\\n\")\n            return(invisible())\n        }\n    }\n\n\nNow, the Easter Egg. The conditional on lines 14-15 evaluates to TRUE if there were four nested ? functions. In this case, a message about the Oracle of Delphi is printed at the console.\n\n????sum\n## Contacting Delphi...the oracle is unavailable.\n## We apologize for any inconvenience.\n\n\nMoving on, we now deal with the double and triple colon operators (:: and :::):\n\n\n    if (is.call(topicExpr) && (topicExpr[[1L]] == \"::\" || topicExpr[[1L]] == \n        \":::\")) {\n        package <- as.character(topicExpr[[2L]])\n        topicExpr <- topicExpr[[3L]]\n    }\n    else package <- NULL\n\n\nIn the presence of these operators, we assign the relavent package to the package variable and the function to the topicExpr variable. Below, we have included an example of how this works:\n\ntopicExpr <- substitute(ggplot2::geom_point)\n\ntopicExpr[[1]]\n## `::`\ntopicExpr[[2]]\n## ggplot2\ntopicExpr[[3]]\n## geom_point\n\nIf there is no colon operator designating the desired package, package is set to NULL on line 28.\n\nFinally, it’s time to actually access the documentation. First, the case of search being TRUE (??) is taken care of:\n\n\n    if (search) {\n        if (is.null(type)) \n            return(eval(substitute(help.search(TOPIC, package = PACKAGE), \n                list(TOPIC = as.character(topicExpr), PACKAGE = package))))\n        else return(eval(substitute(help.search(TOPIC, fields = FIELD, \n            package = PACKAGE), list(TOPIC = as.character(topicExpr), \n            FIELD = as.character(type), PACKAGE = package))))\n    }\n\n\nWe see that the function searching through the documentation is help.search() – the variables we have specified thusfar are provided as arguments and we’re done.\n\nNow we take care of the case where search is FALSE and type is NULL. Remember, type is NULL whenever the argument e2 is not supplied—  the most common use-case.\n\n\n    else {\n        if (is.null(type)) {\n            if (is.call(topicExpr)) \n                return(.helpForCall(topicExpr, parent.frame()))\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else e1\n            return(eval(substitute(help(TOPIC, package = PACKAGE), \n                list(TOPIC = topic, PACKAGE = package))))\n        }\n\n\nA few interesting things to note. First, we deal with the scenario where topicExpr is a call, in which case the function being used to access documentation is the unexported utils:::.helpforCall(). I haven’t dug through its body, but it looks like this is to allow users to execute code like ?sum() (instead of the more typical ?sum). But, I’ve noticed that it doesn’t work for everything—for an example run ?c() .\n\nStarting on line 41, we have the main way ? leads to documentation. This is how code like ?sum is evaluated, via a call to help() on line 44. Notice that substitute() is being used in a slightly different way than before, substituting the values in the “environment” defined on line 45 before eval() is run. (It is used the same way in the previous code chunk, on lines 31 and 33.)\n\nThe rest of the code is just dealing with the case where type and topic was specified by e1 and e2 arguments, respectively. It’s really just repeating what we’ve seen already, with the small addition of using utils:::.tryHelp() and utils:::topicName() functions.\n\n\n        else {\n            type <- if (is.name(type)) \n                as.character(type)\n            else e1\n            topic <- if (is.name(topicExpr)) \n                as.character(topicExpr)\n            else {\n                if (is.call(topicExpr) && identical(type, \"method\")) \n                  return(.helpForCall(topicExpr, parent.frame(), \n                    FALSE))\n                e2\n            }\n            if (type == \"package\") \n                package <- topic\n            h <- .tryHelp(topicName(type, topic), package = package)\n            if (is.null(h)) {\n                if (is.language(topicExpr)) \n                  topicExpr <- deparse(topicExpr)\n                stop(gettextf(\"no documentation of type %s and topic %s (or error in processing help)\", \n                  sQuote(type), sQuote(topicExpr)), domain = NA)\n            }\n            h\n        }\n    }\n}\n\n\n\nSo, what have we learned? ? is a convenience function wrapping around functions like help() and help.search(). It’s main purpose is to parse the different ways a user might refer to an object (e.g. ?ggplot2::geom_point, ??knn, ?sum(), ?sum).\n\n\n\nhelp()\nNow that we have a good grasp on what’s going on with ?, let’s see how help() works. Let’s start by echoing the body of the function:\n\nhelp\n\nfunction (topic, package = NULL, lib.loc = NULL, verbose = getOption(\"verbose\"), \n    try.all.packages = getOption(\"help.try.all.packages\"), help_type = getOption(\"help_type\")) \n{\n    types <- c(\"text\", \"html\", \"pdf\")\n    help_type <- if (!length(help_type)) \n        \"text\"\n    else match.arg(tolower(help_type), types)\n    if (!missing(package)) \n        if (is.name(y <- substitute(package))) \n            package <- as.character(y)\n    if (missing(topic)) {\n        if (!is.null(package)) {\n            if (interactive() && help_type == \"html\") {\n                port <- tools::startDynamicHelp(NA)\n                if (port <= 0L) \n                  return(library(help = package, lib.loc = lib.loc, \n                    character.only = TRUE))\n                browser <- if (.Platform$GUI == \"AQUA\") {\n                  get(\"aqua.browser\", envir = as.environment(\"tools:RGUI\"))\n                }\n                else getOption(\"browser\")\n                browseURL(paste0(\"http://127.0.0.1:\", port, \"/library/\", \n                  package, \"/html/00Index.html\"), browser)\n                return(invisible())\n            }\n            else return(library(help = package, lib.loc = lib.loc, \n                character.only = TRUE))\n        }\n        if (!is.null(lib.loc)) \n            return(library(lib.loc = lib.loc))\n        topic <- \"help\"\n        package <- \"utils\"\n        lib.loc <- .Library\n    }\n    ischar <- tryCatch(is.character(topic) && length(topic) == \n        1L, error = function(e) FALSE)\n    if (!ischar) {\n        reserved <- c(\"TRUE\", \"FALSE\", \"NULL\", \"Inf\", \"NaN\", \n            \"NA\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\")\n        stopic <- deparse1(substitute(topic))\n        if (!is.name(substitute(topic)) && !stopic %in% reserved) \n            stop(\"'topic' should be a name, length-one character vector or reserved word\")\n        topic <- stopic\n    }\n    paths <- index.search(topic, find.package(if (is.null(package)) \n        loadedNamespaces()\n    else package, lib.loc, verbose = verbose))\n    try.all.packages <- !length(paths) && is.logical(try.all.packages) && \n        !is.na(try.all.packages) && try.all.packages && is.null(package) && \n        is.null(lib.loc)\n    if (try.all.packages) {\n        for (lib in .libPaths()) {\n            packages <- .packages(TRUE, lib)\n            packages <- packages[is.na(match(packages, .packages()))]\n            paths <- c(paths, index.search(topic, file.path(lib, \n                packages)))\n        }\n        paths <- paths[nzchar(paths)]\n    }\n    structure(unique(paths), call = match.call(), topic = topic, \n        tried_all_packages = try.all.packages, type = help_type, \n        class = \"help_files_with_topic\")\n}\n<bytecode: 0x56147b430c80>\n<environment: namespace:utils>\n\n\nOf course, we’ll break this down into more digestible chunks.\n\nFirst, we are determining what format of documentation to get. There’s weird argument matching going on, but the main idea is that help can be served up in three forms: text, html, and pdf. By default, help() looks at the global option \"help_type\" for this.\n\n\nfunction (topic, package = NULL, lib.loc = NULL, verbose = getOption(\"verbose\"),\n  try.all.packages = getOption(\"help.try.all.packages\"), help_type = getOption(\"help_type\")) \n{\n    types <- c(\"text\", \"html\", \"pdf\")\n    help_type <- if (!length(help_type)) \n        \"text\"\n    else match.arg(tolower(help_type), types)\n\n\n\n\n\nNext, if the package argument is specified, we check that it is a name after it’s been quoted. If it is, the quoted argument is coerced into a string for later.\n\n\n    if (!missing(package)) \n        if (is.name(y <- substitute(package))) \n            package <- as.character(y)\n\n\n\nNow, we deal with the case where topic is not specified. This is not the typical case, topic is the first formal of help. For example, when you run help(geom_point) you’re setting topic = geom_point. However, this allows for things like help(package = ggplot2).\nThis is what’s going on in lines 13-27, help() is figuring out how to call library() correctly, given the user’s environment. It turns out that in addition to loading/attaching packages, when the help argument of library() is specified it returns information regarding the specified package (in an object of class \"packageInfo\").\n\n\n    if (missing(topic)) {\n        if (!is.null(package)) {\n            if (interactive() && help_type == \"html\") {\n                port <- tools::startDynamicHelp(NA)\n                if (port <= 0L) \n                  return(library(help = package, lib.loc = lib.loc, \n                    character.only = TRUE))\n                browser <- if (.Platform$GUI == \"AQUA\") {\n                  get(\"aqua.browser\", envir = as.environment(\"tools:RGUI\"))\n                }\n                else getOption(\"browser\")\n                browseURL(paste0(\"http://127.0.0.1:\", port, \"/library/\", \n                  package, \"/html/00Index.html\"), browser)\n                return(invisible())\n            }\n            else return(library(help = package, lib.loc = lib.loc, \n                character.only = TRUE))\n        }\n        if (!is.null(lib.loc)) \n            return(library(lib.loc = lib.loc))\n        topic <- \"help\"\n        package <- \"utils\"\n        lib.loc <- .Library\n    }\n\n\nNote, we’re making use of the lib.loc argument. It specifies the location of the R library trees on the user’s machine. By default, its value is NULL—this corresponds to the libraries according to .libPaths().\n\nNext is some simple cleaning-up of topic (which, at this point, we know was specified). Lines 35 and 36 are interesting, note the wrapping of the conditional in a TryCatch().\n\n\n    ischar <- tryCatch(is.character(topic) && length(topic) == \n        1L, error = function(e) FALSE)\n    if (!ischar) {\n        reserved <- c(\"TRUE\", \"FALSE\", \"NULL\", \"Inf\", \"NaN\", \n            \"NA\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\")\n        stopic <- deparse1(substitute(topic))\n        if (!is.name(substitute(topic)) && !stopic %in% reserved) \n            stop(\"'topic' should be a name, length-one character vector or reserved word\")\n        topic <- stopic\n    }\n\n\nAfter this chunk, we know that topic is a string of length 1.\n\nThe next step is to use the unexported function utils:::index.search() to search through relevant package for topic. This involves either searching through the entire set of packages in loadedNamespaces() or the specified package.\n\n\n    paths <- index.search(topic, find.package(if (is.null(package)) \n        loadedNamespaces()\n    else package, lib.loc, verbose = verbose))\n\n\nBelow, I’ve included (truncated) output from a few of these functions so that you can see what’s going on:\n\nloadedNamespaces()[1:4]\n## [1] \"grDevices\" \"digest\"    \"jsonlite\"  \"magrittr\"\n\nfind.package(loadedNamespaces())[1:4]\n## [1] \"/usr/lib/R/library/grDevices\"          \n## [2] \"/usr/local/lib/R/site-library/digest\"  \n## [3] \"/usr/local/lib/R/site-library/jsonlite\"\n## [4] \"/usr/local/lib/R/site-library/magrittr\"\n\nutils:::index.search(\"anova\", find.package(loadedNamespaces()))\n## [1] \"/usr/lib/R/library/stats/help/anova\"\n\n\nNext, we’re cleaning up the try.all.packages argument. This sequence of logical operators works together to 1.) coerce try.all.packages into a logical and 2.) ensure try.all.packages is FALSE if at all possible (according to the documentation, if try.all.packages is TRUE there might be performance issues).\nBy default (and when it is called from ?), try.all.packages is FALSE, so this isn’t of much consequence.\n\n\n    try.all.packages <- !length(paths) && is.logical(try.all.packages) && \n        !is.na(try.all.packages) && try.all.packages && is.null(package) && \n        is.null(lib.loc)\n\n\n\nHere is where try.all.packages is used. If it is TRUE, an index.search() is performed for topic in every package in the.libPaths() directory with results being included in paths.\n\n\n    if (try.all.packages) {\n        for (lib in .libPaths()) {\n            packages <- .packages(TRUE, lib)\n            packages <- packages[is.na(match(packages, .packages()))]\n            paths <- c(paths, index.search(topic, file.path(lib, \n                packages)))\n        }\n        paths <- paths[nzchar(paths)]\n    }\n\n\n\nFinally, we have the end of help(). This is the code that fetches/loads the relevant documentation. If everything has gone correctly, R will try to find a way to show you the corresponding documentation. (If try.all.packages is TRUE, a search results page will be shown instead). In Rstudio, for example, the documentation file will appear in the “Help” pane.\n\n\n    structure(unique(paths), call = match.call(), topic = topic, \n        tried_all_packages = try.all.packages, type = help_type, \n        class = \"help_files_with_topic\")\n}\n\n\nWhy does this structure() call result in the documentation being displayed? I have no idea. I imagine it has something to do with the print method of the \"help_files_with_topic\" class— I haven’t been able to find great documentation on these details.\n\nTry it for yourself! Run the following code, it should bring up the documentation for stats::anova():\n\ntemp_pkgs <- find.package(\n  if (TRUE) loadedNamespaces() else \"stats\", \n  lib.loc = NULL, verbose = getOption(\"verbose\")\n)\n\ntemp_path <- utils:::index.search(\"anova\", temp_pkgs)\n\nstructure(temp_path, call = match.call(), topic = \"anova\", \n    tried_all_packages = FALSE, type = \"html\", \n    class = \"help_files_with_topic\")\n\n\nSo, what have we learned? Documentation for functions of loaded packages are accessed via a combination of the functions loadedNamespaces(), find.package(), and utils:::index.search(). If we want to access documentation of functions for packages that are not loaded, we need to use the functions .libPaths(), .packages(), and utils:::index.search()."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Feb 15, 2022\n\n\nJames Otto\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\nJan 24, 2022\n\n\nJames Otto\n\n\n\n\n\n\nNo matching items"
  }
]